package com.datastax.oss.driver.mapper.model.inventory;

import com.datastax.oss.driver.api.core.MappedAsyncPagingIterable;
import com.datastax.oss.driver.api.core.PagingIterable;
import com.datastax.oss.driver.api.core.cql.AsyncResultSet;
import com.datastax.oss.driver.api.core.cql.BoundStatement;
import com.datastax.oss.driver.api.core.cql.BoundStatementBuilder;
import com.datastax.oss.driver.api.core.cql.PreparedStatement;
import com.datastax.oss.driver.api.core.cql.ResultSet;
import com.datastax.oss.driver.api.core.cql.Row;
import com.datastax.oss.driver.api.core.cql.SimpleStatement;
import com.datastax.oss.driver.api.core.data.UdtValue;
import com.datastax.oss.driver.internal.core.util.concurrent.BlockingOperation;
import com.datastax.oss.driver.internal.core.util.concurrent.CompletableFutures;
import com.datastax.oss.driver.internal.mapper.DaoBase;
import com.datastax.oss.driver.internal.mapper.MapperContext;
import java.lang.Override;
import java.lang.Throwable;
import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.CompletionStage;

/**
 * Generated by the DataStax driver mapper, do not edit directly.
 */
public class ProductDaoImpl__MapperGenerated extends DaoBase implements ProductDao {
  private final ProductHelper__MapperGenerated productHelper;

  private final DimensionsHelper__MapperGenerated dimensionsHelper;

  private final PreparedStatement saveStatement;

  private final PreparedStatement saveWithBoundTimestampStatement;

  private ProductDaoImpl__MapperGenerated(MapperContext context,
      ProductHelper__MapperGenerated productHelper,
      DimensionsHelper__MapperGenerated dimensionsHelper, PreparedStatement saveStatement,
      PreparedStatement saveWithBoundTimestampStatement) {
    super(context);
    this.productHelper = productHelper;
    this.dimensionsHelper = dimensionsHelper;
    this.saveStatement = saveStatement;
    this.saveWithBoundTimestampStatement = saveWithBoundTimestampStatement;
  }

  public static CompletableFuture<ProductDao> initAsync(MapperContext context) {
    try {
      // Initialize all entity helpers
      ProductHelper__MapperGenerated productHelper = new ProductHelper__MapperGenerated(context);
      DimensionsHelper__MapperGenerated dimensionsHelper = new DimensionsHelper__MapperGenerated(context);
      List<CompletionStage<PreparedStatement>> prepareStages = new ArrayList<>();
      // Prepare the statement for `save(com.datastax.oss.driver.mapper.model.inventory.Product)`:
      SimpleStatement saveStatement_simple = SimpleStatement.newInstance(productHelper.insert().asCql());
      CompletionStage<PreparedStatement> saveStatement = prepare(saveStatement_simple, context);
      prepareStages.add(saveStatement);
      // Prepare the statement for `saveWithBoundTimestamp(com.datastax.oss.driver.mapper.model.inventory.Product,long)`:
      SimpleStatement saveWithBoundTimestampStatement_simple = SimpleStatement.newInstance(productHelper.insert().asCql() + " USING TIMESTAMP :timestamp");
      CompletionStage<PreparedStatement> saveWithBoundTimestampStatement = prepare(saveWithBoundTimestampStatement_simple, context);
      prepareStages.add(saveWithBoundTimestampStatement);
      // Build the DAO when all statements are prepared
      return CompletableFutures.allSuccessful(prepareStages)
          .thenApply(v -> (ProductDao) new ProductDaoImpl__MapperGenerated(context,
              productHelper,
              dimensionsHelper,
              CompletableFutures.getCompleted(saveStatement),
              CompletableFutures.getCompleted(saveWithBoundTimestampStatement)))
          .toCompletableFuture();
    } catch (Throwable t) {
      return CompletableFutures.failedFuture(t);
    }
  }

  public static ProductDao init(MapperContext context) {
    BlockingOperation.checkNotDriverThread();
    return CompletableFutures.getUninterruptibly(initAsync(context));
  }

  @Override
  public BoundStatement set(Product product, BoundStatement boundStatement) {
    return productHelper.set(product, boundStatement);
  }

  @Override
  public void set(BoundStatementBuilder builder, Product product) {
    productHelper.set(product, builder);
  }

  @Override
  public void set(Dimensions dimensions, UdtValue udtValue) {
    dimensionsHelper.set(dimensions, udtValue);
  }

  @Override
  public Product get(Row row) {
    return productHelper.get(row);
  }

  @Override
  public PagingIterable<Product> get(ResultSet resultSet) {
    return resultSet.map(productHelper::get);
  }

  @Override
  public MappedAsyncPagingIterable<Product> get(AsyncResultSet resultSet) {
    return resultSet.map(productHelper::get);
  }

  @Override
  public Product getOne(ResultSet resultSet) {
    Row row = resultSet.one();
    return (row == null) ? null : productHelper.get(row);
  }

  @Override
  public Product getOne(AsyncResultSet resultSet) {
    Row row = resultSet.one();
    return (row == null) ? null : productHelper.get(row);
  }

  @Override
  public void save(Product product) {
    BoundStatementBuilder boundStatementBuilder = saveStatement.boundStatementBuilder();
    productHelper.set(product, boundStatementBuilder);

    BoundStatement boundStatement = boundStatementBuilder.build();
    execute(boundStatement);
  }

  @Override
  public Product saveWithBoundTimestamp(Product product, long timestamp) {
    BoundStatementBuilder boundStatementBuilder = saveWithBoundTimestampStatement.boundStatementBuilder();
    productHelper.set(product, boundStatementBuilder);
    // timestamp:
    boundStatementBuilder = boundStatementBuilder.setLong("timestamp", timestamp);

    BoundStatement boundStatement = boundStatementBuilder.build();
    return executeAndMapToSingleEntity(boundStatement, productHelper);
  }
}
